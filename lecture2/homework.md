# Домашнее задание

## Освоение Git 

1. Завести аккаунт на [GitHub](https://github.com/), создать публичный репозиторий для сдачи домашних заданий.
2. Склонировать созданный репозиторий через ssh, например, `git clone git@github.com:<your-name>/golang-course.git`.
3. Завести Pull Request с домашними заданиями первой лекции (желательно задания каждой лекции класть в отдельную соответствующе названную папку) следующим образом:
    1) `git checkout -b dev/<your-name>/add-hw1`
    2) `git add ./lecture1/`
    3) `git status` -- файлы домашних заданий должны подсвечиваться зеленым. Никаких лишних файлов зеленым не должно светиться
    4) `git commit -m "Add homework for lecture 1"`
    5) `git push origin`
    6) в GitHub открыть созданный репозиторий, найти запушенную в п.1 ветку и создать Pull Request (проверить, что там есть понятный заголовок и описание).
    7) Когда в PR будет написано, что его можно мерджить (все ДЗ сделано правильно), нажать на кнопку Merge Request.
    8) `git checkout master`
    9) сделать `git pull origin master` (чтобы спуллить изменения, сделанные в репозитории на Github, к себе локально на компьютер)
    10) Перейти к пункту 1, если нужно открыть новый PR.
4. Аналогичные Pull Requestы надо заводить на домашние задания к каждой лекции.

## Concurrency

### 1. Конвейер по определению четности чисел

Реализовать паттерн `пайплайн` из двух горутин: первая в цикле генерирует 10000 рандомных целых чисел (можно воспользоваться [rand.Intn](https://pkg.go.dev/math/rand#Rand.Intn)) и пишет их в канал, вторая читает из канала числа, определяет их четность и печатает результат.

(!) Второй горутине не обязательно знать, сколько должно быть чисел -- для завершения ей достаточно канала.

### 2. Показания датчиков

Есть три датчика, каждый из которых отправляет свои показания (числа) 
с разной периодичностью:
 - датчик 1 отправляет данные каждые 500 мс;
 - датчик 2 отправляет данные каждые 300 мс;
 - датчик 3 отправляет данные каждые 700 мс.

Данные от датчиков поступают асинхронно и с разной скоростью.
Написать программу, которая будет считывать показания всех датчиков 
и выводить их в порядке поступления.

Программа должна завершиться после сбора N показаний, где N -- 
фиксированное натуральное число.

Note: программа не должна зависеть от числа датчиков, датчиков в общем случае может быть M (просто по условию M = 3).

### 3. Хатико

Если в канал никто не пишет, читатели заблокируются на чтении канала и будут ждать значений до тех пор, пока в канал кто-то не напишет. Чтобы ожидание было не слишком долгим, обычно из канала читают (или в канал пишут) по таймауту -- т.е., с ограничением по времени, за которое можно написать в канал/прочитать из него.

Реализовать чтение из канала с таймаутом:

    - завести канал;
    - попытаться прочесть из него что-то;
    - после N секунд прекратить читать (воспользоваться для этого функцией [time.After](https://pkg.go.dev/time#After)).

### 4. Пинг-понг

Реализовать игру двух горутин в пинг-понг с помощью двух каналов -- канала для пингов и канала для понгов. Один раунд игры в пинг-понг происходит следующим образом: 

    - первая горутина пишет в канал пингов пинг;
    - вторая горутина читает из канала пингов и печатает "Ping";
    - вторая горутина пишет в канал понгов понг;
    - первая горутина читает из канала понгов и печатает "Pong";

Игра в пинг-понг продолжается 10 раундов, после чего горутины перестают писать и читать из каналов.

### 5. Чтение из канала

Реализовать неблокирующееся чтение из небуферизованного канала.